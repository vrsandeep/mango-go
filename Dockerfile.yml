FROM golang:1.24-alpine AS builder

# Install necessary build tools for CGo and SQLite
RUN apk add --no-cache build-base sqlite-dev

WORKDIR /app

# Copy dependency management files
COPY go.mod go.sum ./
# Download dependencies. This is done in a separate step to leverage Docker's
# layer caching. Dependencies are only re-downloaded if go.mod or go.sum change.
RUN go mod download

COPY . .

# Build the Go application.
# CGO_ENABLED=1 is required by the go-sqlite3 driver.
RUN CGO_ENABLED=1 go build -o /mango-scanner ./cmd/mango-cli
RUN CGO_ENABLED=1 go build -o /mango-server ./cmd/mango-server

# ---- Final Stage ----
# This stage creates the final, minimal image. It only contains the compiled
# binary and its runtime dependencies, making it small and secure.
FROM alpine:latest

# Install runtime dependencies for SQLite
RUN apk add --no-cache sqlite

# Set the working directory
WORKDIR /app

# Copy the compiled binary from the builder stage
COPY --from=builder /mango-scanner /app/mango-scanner
COPY --from=builder /mango-server /app/mango-server

# Copy the configuration and migration files into the image.
# The application will look for these in its working directory.
COPY config.yml .
COPY migrations ./migrations

# The application will scan the library path specified in config.yml.
# It's recommended to mount your manga library as a volume to this path.
# For example, if your config.yml points to "/manga", you would run the
# container with: docker run -v /path/to/your/manga:/manga mango-go
VOLUME /manga

CMD ["/app/mango-server"]
